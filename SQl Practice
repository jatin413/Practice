---Hacker Rank Advance Select Questions
----Occupations

SELECT Doctor, Professor, Singer, Actor
from
(
  SELECT Name, Occupation,
    row_number() over(partition by Occupation order by Name) rn
  from Occupations
) as st
pivot
(
  max(Name)
  FOR Occupation in (Doctor, Professor, Singer, Actor)
) as pivottable


----Interviews

select 
  contests.contest_id, 
  contests.hacker_id, 
  contests.name,
  sum(submissions_sums.sum_submissions),
  sum(submissions_sums.sum_accepted_submissions),
  sum(views_sums.sum_views),
  sum(views_sums.sum_unique_views)
from contests 
join colleges on contests.contest_id = colleges.contest_id
join challenges on colleges.college_id = challenges.college_id

left join 
(select 
  challenge_id,
  sum(total_submissions) as sum_submissions,
  sum(total_accepted_submissions) as sum_accepted_submissions
  from submission_stats group by challenge_id) 
as submissions_sums
on challenges.challenge_id = submissions_sums.challenge_id

left join
(select 
  challenge_id,
  sum(total_views) as sum_views,
  sum(total_unique_views) as sum_unique_views
  from view_stats group by challenge_id) 
as views_sums
on challenges.challenge_id = views_sums.challenge_id

group by contests.contest_id, contests.hacker_id, contests.name

having (
  sum(submissions_sums.sum_submissions) +
  sum(submissions_sums.sum_accepted_submissions) +
  sum(views_sums.sum_views) +
  sum(views_sums.sum_unique_views)
) > 0
order by contests.contest_id


This is the same question as problem #2 in the SQL Chapter of Ace the Data Science Interview!

You are given the tables below containing information on Robinhood trades and users. Write a query to list the top three cities that have the most completed trade orders in descending order. Output the city and number of orders.
SELECT u.city,COUNT(t.order_id)as co 
FROM trades AS t  
JOIN users AS u 
on t.user_id=u.user_id
where t.status='Completed'
group by u.city
ORDER BY co DESC 
LIMIT 3;

Assume you are given the tables below about Facebook pages and page likes. Write a query to return the page IDs of all the Facebook pages that don't have any likes. The output should be in ascending order.
SELECT pg.page_id
FROM pages pg 
left join page_likes pgl 
on pg.page_id=pgl.page_id
WHERE pgl.page_id is NULL ;

Assume that you are given the table below containing information on viewership by device type (where the three types are laptop, tablet, and phone). Define “mobile” as the sum of tablet and phone viewership numbers. Write a query to compare the viewership on laptops versus mobile devices.

Output the total viewership for laptop and mobile devices in the format of "laptop_views", "mobile_views".

SELECT 
SUM(
  case when device_type='laptop' then 1 else 0 end   )lapv,
  SUM(
  case when device_type in ('phone','tablet')
  then 1 else 0 end)as mobv
  from viewership;
  
  
  DATA  LEMUR
  
  select app_id,
            ROUND(100.0 * 
            SUM(CASE WHEN event_type= 'click' then 1 else 0 END) /
                 SUM(CASE WHEN event_type= 'impression' then 1 else 0 END),2) as rd
FROM events
WHERE timestamp>='2022-01-01' and timestamp<='2023-01-01'
GROUP BY app_id;

SELECT user_id, MAX(post_date::date)- MIN(post_date::date) as d
FROM posts
where date_part('year',post_date::date)=2021
group by user_id
HAVING COUNT(post_id )>1 
;


WITH qury as(
SELECT row_number()
OVER(PARTITION BY company_id, title, description)as r, company_id,title,description
FROM job_listings
 ) 
 
 SELECT COUNT(DISTINCT company_id)
 from qury
 where r>1
 
 ;


SELECT COUNT(DISTINCT user_id)
FROM
      ( select user_id,
      rank() 
      OVER(PARTITION BY user_id, product_id ORDER BY  date(purchase_date) ASC) as purchase_no  
      FROM purchases)as r
WHERE purchase_no=2


Assume you are given the table below on Uber transactions made by users. 
Write a query to obtain the third transaction of every user. 
Output the user id, spend and transaction date.

WITH sub AS(
SELECT *,rank() 
OVER(PARTITION BY user_id ORDER BY transaction_date Asc )as r 
FROM transactions)

SELECT user_id, 
  spend, 
  transaction_date  from sub
where sub.r=3
;

The LinkedIn Creator team is looking for power creators who use their personal profile as a company or influencer page. If someone's LinkedIn page has more followers than the company they work for, we can safely assume that person is a power creator.

Write a query to return the IDs of these LinkedIn power creators ordered by the IDs.

Assumption:

Each person with a LinkedIn profile in this database works at one company only.
personal_profiles Table:
Column Name	Type
profile_id	integer
name	string
followers	integer
employer_id	integer
personal_profiles Example Input:
profile_id	name	followers	employer_id
1	Nick Singh	92,000	4
2	Zach Wilson	199,000	2
3	Daliana Liu	171,000	1
4	Ravit Jain	107,000	3
5	Vin Vashishta	139,000	6
6	Susan Wojcicki	39,000	5
company_pages Table:
Column Name	Type
company_id	integer
name	string
followers	integer
company_pages Example Input:
company_id	name	followers
1	The Data Science Podcast	8,000
2	Airbnb	700,000
3	The Ravit Show	6,000
4	DataLemur	200
5	YouTube	1,6000,000
6	DataScience.Vin	4,500
Example Output:
profile_id
1
3
4
5
This output shows that profile IDs 1-5 are all power creators, meaning that they have more followers than their company page.

SELECT p.profile_id
FROM personal_profiles as p join 
company_pages as c 
on p.employer_id=c.company_id
where c.followers <p.followers
ORDER BY p.profile_id;


Assume you are given the table below containing information on Amazon customers and their spend on products belonging to various categories. Identify the top two highest-grossing products within each category in 2022. Output the category, product, and total spend.

product_spend Table:
Column Name	Type
category	string
product	string
user_id	integer
spend	decimal
transaction_date	timestamp
product_spend Example Input:
category	product	user_id	spend	transaction_date
appliance	refrigerator	165	246.00	12/26/2021 12:00:00
appliance	refrigerator	123	299.99	03/02/2022 12:00:00
appliance	washing machine	123	219.80	03/02/2022 12:00:00
electronics	vacuum	178	152.00	04/05/2022 12:00:00
electronics	wireless headset	156	249.90	07/08/2022 12:00:00
electronics	vacuum	145	189.00	07/15/2022 12:00:00
Example Output:
category	product	total_spend
appliance	refrigerator	299.99
appliance	washing machine	219.80
electronics	vacuum	341.00
electronics	wireless headset	249.90





WITH cte AS(
SELECT category,product,sum(spend)as s
FROM product_spend
where transaction_date>='2022-01-01' and transaction_date<='2022-12-31'
GROUP BY category,product
),
tops as (
SELECT *,
RANK() OVER(PARTITION BY category ORDER BY s DESC )as ranking
from cte)

SELECT category,product, s from tops
where ranking<=2
ORDER BY category, ranking;
  
  
  For every customer that bought Photoshop, return a list of their customer_id, and how much they spent in total for other Adobe products excluding Photoshop.

Sort your answer by customer_id in ascending order.

adobe_transactions Table:
Column Name	Type
customer_id	integer
product	integer
revenue	integer
adobe_transactions Example Input:
customer_id	product	revenue
123	Photoshop	50
123	Premier Pro	100
123	After Effects	50
234	Illustrator	200
234	Premier Pro	100
Example Output:
customer_id	revenue
123	150
Explanation: User 123 bought Photoshop, Premier Pro + After Effects, spending $150 for those products. We don't output user 234 because they didn't buy Photoshop.
  
  
  
SELECT customer_id, sum(revenue) as revenue FROM adobe_transactions
WHERE product !='Photoshop' and customer_id in (select customer_id FROM adobe_transactions where product='Photoshop')
group by customer_id
ORDER BY customer_id ;



Given a table of candidates and their skills, you're tasked with finding the candidates best suited for an open Data Science job. You want to find candidates who are proficient in Python, Tableau, and PostgreSQL.

Write a SQL query to list the candidates who possess all of the required skills for the job. Sort the the output by candidate ID in ascending order.

Assumption:

There are no duplicates in the candidates table.
candidates Table:
Column Name	Type
candidate_id	integer
skill	varchar
candidates Example Input:
candidate_id	skill
123	Python
123	Tableau
123	PostgreSQL
234	R
234	PowerBI
234	SQL Server
345	Python
345	Tableau
Example Output:
candidate_id
123




WITH cte as(
SELECT candidate_id,SUM( CASE WHEN 
 skill in ('Python', 'Tableau',  'PostgreSQL') then 1 ELSE 0 END)as s
FROM candidates
group by candidate_id
)

SELECT candidate_id 
from cte
where s>=3
group by candidate_id
ORDER BY candidate_id ;


or


SELECT candidate_id, COUNT(skill)
from candidates
where skill in ('Python', 'Tableau', 'PostgreSQL')
GROUP BY candidate_id
having COUNT(skill)=3
ORDER BY candidate_id;

Find the top 5 businesses with most reviews. Assume that each row has a unique business_id such that the total reviews for each business is listed on each row. Output the business name along with the total number of reviews and order your results by the total reviews in descending order.

select   name,review_count  
from yelp_business
order by review_count desc
limit 5;

Find the 3 most profitable companies in the entire world.
Output the result along with the corresponding company name.
Sort the result based on profits in descending order.

select company,profits 
from forbes_global_2010_2014
order by profits desc
limit 3;

Rank guests based on the number of messages they've exchanged with the hosts. Guests with the same number of messages as other guests should have the same rank. Do not skip rankings if the preceding rankings are identical.
Output the rank, guest id, and number of total messages they've sent. Order by the highest number of total messages first.

select dense_rank() over( order by sum(n_messages) desc )as rnk,id_guest,sum(n_messages)
from airbnb_contacts
group by id_guest
order by sum(n_messages)desc ;


Given the reviews table, write a query to get the average stars for each product every month.

The output should include the month, product_id, and average star rating.

Round the average star rating to two decimal places.
Sort the output based on month and product_id.

SELECT date_part('month',submit_date),product_id,ROUND(AVG(stars),2) FROM reviews
GROUP BY date_part('month',submit_date),product_id
ORDER BY date_part('month',submit_date),product_id;



You are given a table of Facebook posts from users who posted at least twice in 2021. Write a query to find the average number of days (with decimals) between each user’s posts during 2021.

Output the user and the average number of the days they waited between posts.

Assumptions:

A single user can post several times per day.
When calculating differences between dates, output the component of the time interval representing days.
Example output: 5.5 days
posts Table:
Column Name	Type
user_id	integer
post_id	integer
post_date	timestamp
post_content	timestamp
posts Example Input:
user_id	post_id	post_date	post_content
151652	599415	07/10/2021 12:00:00	Need a hug
151652	994156	07/15/2021 12:00:00	Does anyone have an extra iPhone charger to sell?
661093	624356	07/29/2021 13:00:00	Bed. Class 8-12. Work 12-3. Gym 3-5 or 6. Then class 6-10. Another day that's gonna fly by. I miss my girlfriend
004239	784254	07/04/2021 11:00:00	Happy 4th of July!
661093	442560	07/08/2021 14:00:00	Just going to cry myself to sleep after watching Marley and Me.
151652	111766	07/12/2021 19:00:00	I'm so done with covid - need travelling ASAP!
Example Output:
user_id	days_between
151652	2.5
661093	21
Explanation: User 661903 had 2 days between the first and the second post; and 3 days between the second and the third post. Thus, the average is 2.5.




SELECT user_id,
date_part('day',MAX(post_date)-MIN(post_date))/
(COUNT(post_id)-1) as bw
from posts
where EXTRACT(year from post_date)=2021
GROUP BY user_id 
HAVING count(post_id)>=2;


Assume you are given the table below on user transactions. Write a query to obtain the list of customers whose first transaction was valued at $50 or more. Output the number of users.

Clarification: Use the transaction_date field to determine which transaction should be labeled as the first for each user. Use a specific function (we can't give too much away!) to account for scenarios where a user had multiple transactions on the same day, and one of those was the first.

user_transactions Table:
Column Name	Type
transaction_id	integer
user_id	integer
spend	decimal
transaction_date	timestamp
user_transactions Example Input:
transaction_id	user_id	spend	transaction_date
759274	111	49.50	02/03/2022 00:00:00
850371	111	51.00	03/15/2022 00:00:00
615348	145	36.30	03/22/2022 00:00:00
137424	156	151.00	04/04/2022 00:00:00
248475	156	87.00	04/16/2022 00:00:00
Example Output:
users
1
Explanation: Only user 156 has a first transaction valued over $50.


with cte as(
SELECT *,
RANK()OVER(PARTITION BY user_id ORDER BY transaction_date Asc)as rnk 
FROM user_transactions

)

select count(DISTINCT user_id)
from cte
where rnk=1 and  spend >=50
;


The table below contains information about tweets over a given period of time. Calculate the 3-day rolling average of tweets published by each user for each date that a tweet was posted. Output the user id, tweet date, and rolling averages rounded to 2 decimal places.

Important Assumptions:

Rows in this table are consecutive and ordered by date.
Each row represents a different day
A day that does not correspond to a row in this table is not counted. The most recent day is the next row above the current row.
Note: Rolling average is a metric that helps us analyze data points by creating a series of averages based on different subsets of a dataset. It is also known as a moving average, running average, moving mean, or rolling mean.

tweets Table:
Column Name	Type
tweet_id	integer
user_id	integer
tweet_date	timestamp
tweets Example Input:
tweet_id	user_id	tweet_date
214252	111	06/01/2022 12:00:00
739252	111	06/01/2022 12:00:00
846402	111	06/02/2022 12:00:00
241425	254	06/02/2022 12:00:00
137374	111	06/04/2022 12:00:00
Example Output:
user_id	tweet_date	rolling_avg_3days
111	06/01/2022 12:00:00	2.00
111	06/02/2022 12:00:00	1.50
111	06/04/2022 12:00:00	1.33
254	06/02/2022 12:00:00	1.00
Explanation
User 111 made 2 tweets on 06/01/2022, and 1 tweet the next day. By 06/02/2022, the user had made in total 3 tweets over the course of 2 days; thus, the rolling average is 3/2=1.5. By 06/04/2022, there are 4 tweets that were made during 3 days: 4/3 = 1.33 rolling average.



WITH cte as(
SELECT user_id,tweet_date,COUNT(user_id)as cnt 
FROM tweets
GROUP BY user_id, tweet_date)

SELECT user_id,tweet_date, round(AVG(cnt) OVER(PARTITION BY user_id ORDER BY tweet_date 
rows BETWEEN 2 preceding and current row),2)
from cte;


sqlzoo.net..............................


Guest House Assessment Easy

SELECT booking_date,nights
FROM booking 
 WHERE guest_id=1183;
 
 select b.arrival_time,g.first_name,g.last_name 
from booking as b join guest as g 
on b.guest_id = g.id
where b.booking_date='2016-11-05'  
order by b.arrival_time;

select b.booking_id, b.room_type_requested,b.occupants,sum(r.amount)
from booking as b join rate as r 
on b.room_type_requested=r.room_type
where booking_id in (5152, 5165, 5154 , 5295)
group by b.booking_id ,b.room_type_requested,b.occupants ;

select g.first_name,g.last_name,g.address 
from booking as b join room r 
on r.id=b.room_no
join guest as g
on b.guest_id = g.id 
where r.id=101 and b.booking_date='2016-12-03';


select guest_id,count(nights),sum(nights)
from booking
where guest_id in (1185 , 1270)
group by guest_id;


Ruth Cadbury. Show the total amount payable by guest Ruth Cadbury for her room bookings. You should JOIN to the rate table using room_type_requested and occupants.


select sum(r.amount*b.nights) from booking as b join guest as g on b.guest_id =g.id 
join
rate as r on b.room_type_requested=r.room_type and b.occupants=r.occupancy 
where g.first_name='Ruth' and last_name='Cadbury'


Including Extras. Calculate the total bill for booking 5346 including extras.

 SELECT sum(rate.amount) + SUM(extra.amount) AS amount
FROM booking JOIN rate ON booking.room_type_requested = rate.room_type AND booking.occupants = rate.occupancy
  JOIN extra ON booking.booking_id = extra.booking_id
WHERE booking.booking_id = 5346
group by rate.amount;

Edinburgh Residents. For every guest who has the word “Edinburgh” in their address show the total number of nights booked. Be sure to include 0 for those guests who have never had a booking. Show last name, first name, address and number of nights. Order by last name then first name.

SELECT guest.last_name, guest.first_name, guest.address, 
  CASE WHEN SUM(booking.nights) IS NOT NULL
                  THEN  SUM(booking.nights)
                  ELSE  0
             END AS nights
FROM guest LEFT JOIN booking ON guest.id = booking.guest_id;

 
 How busy are we? For each day of the week beginning 2016-11-25 show the number of bookings starting that day. Be sure to show all the days of the week in the correct order.


select booking_date, count(arrival_time) from booking 
where booking_date  between '2016-11-25' and '2016-12-01' 
group by booking_date;

How many guests? Show the number of guests in the hotel on the night of 2016-11-21. Include all occupants who checked in that day but not those who checked out.

select sum(occupants) from booking
where booking_date<='2016-11-21' and
       DATE_ADD(booking_date, INTERVAL(nights) DAY) > '2016-11-21';
       
       
       
Google marketing managers are analyzing the performance of various advertising accounts over the last month. They need your help to gather the relevant data.

Write a query to calculate the return on ad spend (ROAS) for each advertiser across all ad campaigns. Round your answer to 2 decimal places, and order your output by the advertiser_id.

Hint: ROAS = Ad Revenue / Ad Spend

ad_campaigns Table:
Column Name	Type
campaign_id	integer
spend	integer
revenue	float
advertiser_id	integer
ad_campaigns Example Input:
campaign_id	spend	revenue	advertiser_id
1	5000	7500	3
2	1000	900	1
3	3000	12000	2
4	500	2000	4
5	100	400	4
Example Output:
advertiser_id	ROAS
1	0.9
2	4
3	1.5
4	4
Explanation
The example output shows that advertiser_id 1 returned 90% of their ad spend, advertiser_id 2 returned 400% of their ad spend, and so on.

SELECT advertiser_id, round(cast(sum(revenue)/sum(spend) as numeric),2) as ROAS
FROM ad_campaigns
GROUP BY advertiser_id
ORDER BY advertiser_id;




The LinkedIn Creator team is looking for power creators who use their personal profile as a company or influencer page. If someone's LinkedIn page has more followers than the company they work for, we can safely assume that person is a power creator. Write a query to return the IDs of these LinkedIn power creators.

This is the second part of the question, so make sure your start with Part 1 if you haven't completed that yet!

Assumption: A person can work at multiple companies.

personal_profiles Table:
Column Name	Type
profile_id	integer
name	string
followers	integer
personal_profiles Example Input:
profile_id	name	followers
1	Nick Singh	92,000
2	Zach Wilson	199,000
3	Daliana Liu	171,000
4	Ravit Jain	107,000
5	Vin Vashishta	139,000
6	Susan Wojcicki	39,000
employee_company Table:
Column Name	Type
personal_profile_id	integer
company_id	integer
employee_company Example Input:
personal_profile_id	company_id
1	4
1	9
2	2
3	1
4	3
5	6
6	5
company_pages Table:
Column Name	Type
company_id	integer
name	string
followers	integer
company_pages Example Input:
company_id	name	followers
1	The Data Science Podcast	8,000
2	Airbnb	700,000
3	The Ravit Show	6,000
4	DataLemur	200
5	YouTube	1,6000,000
6	DataScience.Vin	4,500
9	Ace The Data Science Interview	4479
Example Output:
profile_id
1
3
4
5
This output shows that profile IDs 1-5 are all power creators, meaning that they have more followers than their each of their company pages, whether they work for 1 company or 3.



with popcom as (
select ec.personal_profile_id, MAX(cp.followers) as mxf
from employee_company as ec LEFT JOIN company_pages as cp
on ec.company_id=cp.company_id
GROUP BY ec.personal_profile_id
)

SELECT personal_profile_id, mxf,pp.followers from popcom
LEFT JOIN personal_profiles as pp on popcom.personal_profile_id=pp.profile_id
where pp.followers > mxf
;


with cte as (
    select min(lat_n)as n_min,max(lat_n)as n_max,min(long_w)as w_min,max(long_w)as w_max from station )
    
select round(sqrt(power(n_max-n_min,2)+power(w_max-w_min,2)),4) from cte 


select distinct city from station 
where left(city,1) not in ('a','e','i','o','u') and right(city,1) not in ('a','e','i','o','u')


select * from city where countrycode ='JPN'


New TikTok users sign up with their emails and each user receives a text confirmation to activate their account. Assume you are given the below tables about emails and texts.

Write a query to display the ids of the users who did not confirm on the first day of sign-up, but confirmed on the second day.

Assumption:

action_date is the date when the user activated their account and confirmed their sign-up through the text.
emails Table:
Column Name	Type
email_id	integer
user_id	integer
signup_date	datetime
emails Example Input:
email_id	user_id	signup_date
125	7771	06/14/2022 00:00:00
433	1052	07/09/2022 00:00:00
texts Table:
Column Name	Type
text_id	integer
email_id	integer
signup_action	string ('Confirmed', 'Not confirmed')
action_date	datetime
texts Example Input:
text_id	email_id	signup_action	action_date
6878	125	Confirmed	06/14/2022 00:00:00
6997	433	Not Confirmed	07/09/2022 00:00:00
7000	433	Confirmed	07/10/2022 00:00:00
Example Output:
user_id
1052
Explanation: User 1052 is the only user who confirmed their sign up on the second day.

SELECT distinct emails.user_id FROM emails  
 inner join 
texts 
on emails.email_id = texts.email_id
where texts.action_date=emails.signup_date+ interval '1 day'  and texts.signup_action= 'Confirmed';




Given a table of bank deposits and withdrawals, return the final balance for each account.

Assumption:

All the transactions performed for each account are present in the table; no transactions are missing.
transactions Table:
Column Name	Type
transaction_id	integer
account_id	integer
transaction_type	varchar
amount	decimal
transactions Example Input:
transaction_id	account_id	transaction_type	amount
123	101	Deposit	10.00
124	101	Deposit	20.00
125	101	Withdrawal	5.00
126	201	Deposit	20.00
128	201	Withdrawal	10.00
Example Output:
account_id	final_balance
101	25.00
201	10.00
Explanation:
In total, $30.00 were deposited to account 101, and $5.00 were withdrawn. Therefore, the final balance will be $30.00-$5.00 = $25.00


select account_id, sum(CASE 
                        WHEN transaction_type='Deposit' THEN amount
                        ELSE -amount
                        end) as balance_amount 
                        from transactions 
                        GROUP BY account_id ;




Your team at Accenture is helping a Fortune 500 client revamp their compensation and benefits program. The first step in this analysis is to manually review employees who are potentially overpaid or underpaid.

An employee is considered to be potentially overpaid if they earn more than 2 times the average salary for people with the same title. Similarly, an employee might be underpaid if they earn less than half of the average for their title. We'll refer to employees who are both underpaid and overpaid as compensation outliers for the purposes of this problem.

Write a query that shows the following data for each compensation outlier: employee ID, salary, and whether they are potentially overpaid or potentially underpaid.

employee_pay Table:
Column Name	Type
employee_id	integer
salary	integer
title	varchar
employee_pay Example Input:
employee_id	salary	title
101	80000	Data Analyst
102	90000	Data Analyst
103	100000	Data Analyst
104	30000	Data Analyst
105	120000	Data Scientist
106	100000	Data Scientist
107	80000	Data Scientist
108	310000	Data Scientist
Example Output:
employee_id	salary	status
104	30000	Underpaid
108	310000	Overpaid
Explanation
In this example, 2 employees qualify as compensation outliers. Employee 104 is a Data Analyst, and the average salary for this position is $75,000. Meanwhile, the salary of employee 104 is less than $37,500 (half of $75,000); therefore, they are underpaid.


WITH payout as(
SELECT employee_id,salary,title,
(AVG(salary) over (PARTITION BY title))*2 as double_avg,
(AVG(salary)OVER(PARTITION BY title))/2 as half_avg
FROM employee_pay
)

SELECT employee_id, salary, CASE 
                                WHEN salary > double_avg then 'Overpaid'
                                when salary < half_avg then 'Underpaid'
                            END AS outlier_status
                            
                            
                            FROM payout
                            where salary>double_avg or salary<half_avg
                            ;
